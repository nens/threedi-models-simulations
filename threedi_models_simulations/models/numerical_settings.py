# coding: utf-8

"""
3Di API

3Di simulation API (latest stable version: v3)   Framework release: 3.4.71   3Di core release: 3.6.10  deployed on:  09:22AM (UTC) on September 01, 2025

The version of the OpenAPI document: v3
Contact: info@nelen-schuurmans.nl
Generated by OpenAPI Generator (https://openapi-generator.tech)

Do not edit the class manually.
"""  # noqa: E501

from __future__ import annotations

import json
import pprint
import re  # noqa: F401
from typing import Any, ClassVar, Dict, List, Optional, Set, Union

from pydantic import BaseModel, ConfigDict, Field, StrictBool, StrictInt
from typing_extensions import Annotated, Self


class NumericalSettings(BaseModel):
    """
    NumericalSettings
    """  # noqa: E501

    id: Optional[StrictInt] = None
    simulation_id: Optional[StrictInt] = None
    pump_implicit_ratio: Union[
        Annotated[float, Field(le=1, strict=True, ge=0)],
        Annotated[int, Field(le=1, strict=True, ge=0)],
    ]
    cfl_strictness_factor_1d: Union[
        Annotated[float, Field(strict=True, ge=1e-14)],
        Annotated[int, Field(strict=True, ge=1)],
    ] = Field(
        description="Strictness of CFL (Courant–Friedrichs–Lewy) condition for 1D."
    )
    cfl_strictness_factor_2d: Union[
        Annotated[float, Field(strict=True, ge=1e-14)],
        Annotated[int, Field(strict=True, ge=1)],
    ] = Field(
        description="Strictness of CFL (Courant–Friedrichs–Lewy) condition for 2D."
    )
    convergence_eps: Union[
        Annotated[float, Field(le=0.0001, strict=True, ge=1e-7)],
        Annotated[int, Field(le=0, strict=True, ge=1)],
    ] = Field(
        description="Minimal convergence criterion for Newton's method, suitable default is 1.0e-5, due to numerical precision."
    )
    convergence_cg: Union[
        Annotated[float, Field(le=1e-7, strict=True, ge=1e-12)],
        Annotated[int, Field(le=0, strict=True, ge=1)],
    ] = Field(
        description="Convergence criterion of cg-method, suitable default is 1.0e-9, due to numerical precision."
    )
    flow_direction_threshold: Union[
        Annotated[float, Field(le=0.01, strict=True, ge=1e-13)],
        Annotated[int, Field(le=0, strict=True, ge=1)],
    ] = Field(
        description="Threshold value for upwind scheme based on flow velocity, suitable default is 1e-06."
    )
    friction_shallow_water_depth_correction: StrictInt = Field(
        description="In case the friction assumptions based on the dominant friction balance gives a structurally underestimation of the friction, you can switch this setting on.  Options:  0 = off 1 = max between avg and divided channel based friction 2 = always linearized 3 = linearizes the depth based on a weighed averaged   If options 3 is used the maximum depth of a thin layer needs to be defined. Do not use in combination with interflow. Suitable default is 0 (OFF)."
    )
    general_numerical_threshold: Union[
        Annotated[float, Field(le=1e-7, strict=True, ge=1e-13)],
        Annotated[int, Field(le=0, strict=True, ge=1)],
    ] = Field(description="Suitable default is 1.0e-8")
    time_integration_method: Optional[StrictInt] = Field(
        default=None,
        description="There are various methods to discretize the equations. At the moment only the first-order, semi-implicit method is supported and tested. Options:  0 = euler implicit ",
    )
    limiter_waterlevel_gradient_1d: StrictInt = Field(
        description="The limiter on the water level gradient allows the model to deal with unrealistically steep gradients. Suitable default is 1."
    )
    limiter_waterlevel_gradient_2d: StrictInt = Field(
        description="The limiter on the water level gradient allows the model to deal with unrealistically steep gradients. Suitable default is 1."
    )
    limiter_slope_crossectional_area_2d: StrictInt = Field(
        description="This limiter starts working in case the depth based on the downstream water level is zero and may be useful in sloping areas. Options:  0 = off 1 = higher order scheme (might be sensitive to instabilities) 2 = cross-sections treated as upwind method volume/surface area 3 = combination traditional method thin layer approach  If option 3 is used the maximum depth of a thin layer needs to be defined. Do not use in combination with interflow."
    )
    limiter_slope_friction_2d: StrictInt = Field(
        description="This limiter starts working in case the depth based on the downstream water level is zero and may be useful in sloping areas. This limiter is mandatory if the limiter_slope_crossectional_area_2d setting is greater than 0. Do not use in combination with interflow. Suitable default is 0 (OFF)  Options:  0 = off 1 = standard "
    )
    max_non_linear_newton_iterations: Annotated[
        int, Field(le=2147483647, strict=True, ge=1)
    ] = Field(
        description="Maximum number of non-linear newton iterations in single time step. Suitable default is 20."
    )
    max_degree_gauss_seidel: Annotated[int, Field(le=2147483647, strict=True, ge=1)] = (
        Field(
            description="Values below are advised for different model types:  700 for 1D flow  7 for 1D and 2D flow  5 for surface 2D flow only  7 for surface and groundwater flow  70 for 1D, 2D surface and groundwater flow or higher.  Play around with this value, can speed up your model significantly, especially in case of ground water flow. Suitable default is 0."
        )
    )
    min_friction_velocity: Union[
        Annotated[float, Field(le=1, strict=True, ge=0)],
        Annotated[int, Field(le=1, strict=True, ge=0)],
    ] = Field(
        description="To guarantee some initial friction only in flooded areas and for large time steps, it is wise to assume a minimum velocity for computing the friction. Suitable default is 0.01."
    )
    min_surface_area: Union[
        Annotated[float, Field(le=1e-7, strict=True, ge=1e-13)],
        Annotated[int, Field(le=0, strict=True, ge=1)],
    ] = Field(description="Suitable default is 1.0e-8.")
    use_preconditioner_cg: StrictInt = Field(
        description="Use pre-conditioner for matrix solver. Increases simulation speed in most cases.  Options:  0 = off 1 = standard . Suitable default is 1 (STANDARD)."
    )
    preissmann_slot: Union[
        Annotated[float, Field(strict=True, ge=0)],
        Annotated[int, Field(strict=True, ge=0)],
    ] = Field(
        description="A conceptual vertical narrow slot providing a conceptual free surface condition for the flow when the water level is above the top of a closed conduit. Often used to guarantee stability. Not necessary in 3Di even for pressurized pipe flow. Note: Works only for circular profiles. Suitable default is 0.0. Unit: m2."
    )
    limiter_slope_thin_water_layer: Union[
        Annotated[float, Field(strict=True, ge=0)],
        Annotated[int, Field(strict=True, ge=0)],
    ] = Field(
        description="Mandatory when using friction_shallow_water_depth_correction option 3 or limiter_slope_crossectional_area_2d option 3. Unit: m"
    )
    use_of_cg: Annotated[int, Field(le=2147483647, strict=True, ge=1)] = Field(
        description="Number of conjugate gradient method iterations, before switching to another method. Suitable default is 20."
    )
    use_nested_newton: StrictBool = Field(
        description="Set to 'True' for 1D calculations with closed profiles to handle non-linearity in volume-water level relation. When set to 'False' it will be used if calculations become non-linear. For sewerage systems it is advised to set this setting to 'True'. Otherwise a suitable default is 'False'"
    )
    flooding_threshold: Union[
        Annotated[float, Field(le=0.05, strict=True, ge=0)],
        Annotated[int, Field(le=0, strict=True, ge=0)],
    ] = Field(
        description="Water depth threshold for flow between 2D cells. Depth relative to lowest bathymetry pixel at the edge between two 2D cells. Suitable default is 0.000001."
    )
    __properties: ClassVar[List[str]] = [
        "id",
        "simulation_id",
        "pump_implicit_ratio",
        "cfl_strictness_factor_1d",
        "cfl_strictness_factor_2d",
        "convergence_eps",
        "convergence_cg",
        "flow_direction_threshold",
        "friction_shallow_water_depth_correction",
        "general_numerical_threshold",
        "time_integration_method",
        "limiter_waterlevel_gradient_1d",
        "limiter_waterlevel_gradient_2d",
        "limiter_slope_crossectional_area_2d",
        "limiter_slope_friction_2d",
        "max_non_linear_newton_iterations",
        "max_degree_gauss_seidel",
        "min_friction_velocity",
        "min_surface_area",
        "use_preconditioner_cg",
        "preissmann_slot",
        "limiter_slope_thin_water_layer",
        "use_of_cg",
        "use_nested_newton",
        "flooding_threshold",
    ]

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )

    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of NumericalSettings from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        * OpenAPI `readOnly` fields are excluded.
        * OpenAPI `readOnly` fields are excluded.
        """
        excluded_fields: Set[str] = set(
            [
                "id",
                "simulation_id",
            ]
        )

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of NumericalSettings from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate(
            {
                "id": obj.get("id"),
                "simulation_id": obj.get("simulation_id"),
                "pump_implicit_ratio": obj.get("pump_implicit_ratio"),
                "cfl_strictness_factor_1d": obj.get("cfl_strictness_factor_1d"),
                "cfl_strictness_factor_2d": obj.get("cfl_strictness_factor_2d"),
                "convergence_eps": obj.get("convergence_eps"),
                "convergence_cg": obj.get("convergence_cg"),
                "flow_direction_threshold": obj.get("flow_direction_threshold"),
                "friction_shallow_water_depth_correction": obj.get(
                    "friction_shallow_water_depth_correction"
                ),
                "general_numerical_threshold": obj.get("general_numerical_threshold"),
                "time_integration_method": obj.get("time_integration_method"),
                "limiter_waterlevel_gradient_1d": obj.get(
                    "limiter_waterlevel_gradient_1d"
                ),
                "limiter_waterlevel_gradient_2d": obj.get(
                    "limiter_waterlevel_gradient_2d"
                ),
                "limiter_slope_crossectional_area_2d": obj.get(
                    "limiter_slope_crossectional_area_2d"
                ),
                "limiter_slope_friction_2d": obj.get("limiter_slope_friction_2d"),
                "max_non_linear_newton_iterations": obj.get(
                    "max_non_linear_newton_iterations"
                ),
                "max_degree_gauss_seidel": obj.get("max_degree_gauss_seidel"),
                "min_friction_velocity": obj.get("min_friction_velocity"),
                "min_surface_area": obj.get("min_surface_area"),
                "use_preconditioner_cg": obj.get("use_preconditioner_cg"),
                "preissmann_slot": obj.get("preissmann_slot"),
                "limiter_slope_thin_water_layer": obj.get(
                    "limiter_slope_thin_water_layer"
                ),
                "use_of_cg": obj.get("use_of_cg"),
                "use_nested_newton": obj.get("use_nested_newton"),
                "flooding_threshold": obj.get("flooding_threshold"),
            }
        )
        return _obj
